package com.example.booksinventory.service;

import com.example.booksinventory.model.Book;
import com.example.booksinventory.model.BookDTO;
import com.example.booksinventory.exception.BookException;
import com.example.booksinventory.model.BookId;
import com.example.booksinventory.repository.BookRepository;
import org.modelmapper.ModelMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
public class BookServiceImplementation implements BookService {
    @Autowired // This means to get the bean called userRepository
    // Which is auto-generated by Spring, we will use it to handle the data

    private final BookRepository bookRepository;
    private final ModelMapper modelMapper;

    public BookServiceImplementation(BookRepository bookRepository, ModelMapper modelMapper) {
        this.bookRepository = bookRepository;
        this.modelMapper = modelMapper;
    }

    @Override
    public BookDTO saveBook(BookDTO bookDTO) {
        boolean isValidBook = BookDTO.isValid(bookDTO);
        if(!isValidBook){
            throw new BookException("Book '" + bookDTO.getId() + "' is not a valid Book", HttpStatus.NOT_ACCEPTABLE);
        }
        Book book = mapToEntity(bookDTO);
        Optional<Book> bookInDB = bookRepository.findById(new BookId(book.getId(), book.getEmail()));
        if(bookInDB.isPresent()){
            throw new BookException("Book '" + book.getId() + "' already exists for '" + book.getEmail() + "'", HttpStatus.CONFLICT);
        }
        return mapToDTO(bookRepository.save(book));
    }

    @Override
    public List<BookDTO> getBooks(Integer page, Integer size, String sort, boolean asc) {
        Sort order;
        if(!asc){
            order = Sort.by(sort).descending();
        } else {
            order = Sort.by(sort);
        }
        Pageable pageable = PageRequest.of(page, size, order);
        Iterable<Book> books = bookRepository.findAll(pageable);

        List<BookDTO> bookDTOList = new ArrayList<>();

        for (Book book: books) {
            bookDTOList.add(mapToDTO(book));
        }

        return bookDTOList;
    }

    @Override
    public List<BookDTO> getBooksByEmail(Integer page, Integer size, String sort, boolean asc, String email) {
        List<BookDTO> books = getBooks(page, size, sort, asc);
        return books.stream().filter(book -> book.getEmail().equals(email)).collect(Collectors.toList());
    }

    @Override
    public BookDTO getBooksByIdentifier(String identifier, String email, String identifierType) {
        Optional<Book> book = bookRepository.findByIndustryIdentifier(identifierType, identifier, email);
        if(book.isPresent() && book.get().getEmail().equals(email)){
            return mapToDTO(book.get());
        }
        throw new BookException("Book '" + identifier + "' does not exists for '" + identifierType + "'", HttpStatus.NOT_FOUND);
    }

    @Override
    public BookDTO getBookById(String id, String email) {
        Optional<Book> book = bookRepository.findById(new BookId(id, email));
        if(!book.isPresent()){
            throw new BookException("Book '" + id + "' does not exists for '" + email + "'", HttpStatus.NOT_FOUND);
        }
        return mapToDTO(book.get());
    }

    @Override
    public BookDTO updateBookById(String id, BookDTO bookDTO) {
        if(!id.equals(bookDTO.getId())){
            throw new BookException("Book '" + id + "' cannot be updated", HttpStatus.BAD_REQUEST);
        }
        boolean isValidBook = BookDTO.isValid(bookDTO);
        if(!isValidBook){
            throw new BookException("Book '" + bookDTO.getId() + "' is not a valid Book", HttpStatus.NOT_ACCEPTABLE);
        }
        bookRepository.save(mapToEntity(bookDTO));
        return  bookDTO;
    }

    @Override
    public void deleteBook(String id, String email) {
        Optional<Book> book = bookRepository.findById(new BookId(id, email));
        if(!book.isPresent()){
            throw new BookException("Book '" + id + "' does not exists for '" + email + "'", HttpStatus.NOT_FOUND);
        }
        bookRepository.deleteById(new BookId(id, email));
    }

    private Book mapToEntity(BookDTO bookDTO){
        Book book = modelMapper.map(bookDTO, Book.class);
        return book;
    }

    private BookDTO mapToDTO(Book book){
        BookDTO bookDTO = modelMapper.map(book, BookDTO.class);
        return bookDTO;
    }

}
